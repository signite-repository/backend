package com.signite.backend.service

import com.signite.backend.domain.dto.UserFormDTO
import com.signite.backend.domain.entity.User
import com.signite.backend.repository.UserCacheRepository
import com.signite.backend.repository.UserRepository
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.*
import reactor.core.publisher.Mono
import reactor.test.StepVerifier

@ExtendWith(MockitoExtension::class)
class AuthServiceTest {

    @Mock
    private lateinit var userRepository: UserRepository
    
    @Mock
    private lateinit var userCacheRepository: UserCacheRepository
    
    private lateinit var authService: AuthService
    
    private lateinit var testUser: User
    private lateinit var testUserForm: UserFormDTO
    
    @BeforeEach
    fun setUp() {
        authService = AuthService(userRepository, userCacheRepository)
        
        // Mock 초기화
        reset(userRepository, userCacheRepository)
        
        testUser = User(
            id = 1,
            username = "testuser",
            email = "test@example.com",
            hashedPassword = "hashedPassword123",
            imageUrl = "profile.jpg",
            githubUrl = "https://github.com/testuser",
            summary = "테스트 사용자"
        )
        
        testUserForm = UserFormDTO().apply {
            username = "testuser"
            password = "hashedPassword123"
        }
    }
    
    @Test
    fun `사용자_생성이_성공적으로_처리된다`() {
        // Given
        val expectedUser = testUser.copy(id = 1)
        whenever(userRepository.save(any<User>())).thenReturn(Mono.just(expectedUser))
        
        // When & Then
        StepVerifier.create(authService.createUser(testUserForm))
            .expectNextMatches { user ->
                user.username == "testuser" &&
                user.hashedPassword == "hashedPassword123" &&
                user.id == 1
            }
            .verifyComplete()
            
        verify(userRepository).save(any<User>())
    }
    
    @Test
    fun `사용자_ID로_조회가_성공적으로_처리된다`() {
        // Given
        whenever(userRepository.findById(1)).thenReturn(Mono.just(testUser))
        
        // When & Then
        StepVerifier.create(authService.getUserById(1))
            .expectNextMatches { user ->
                user.id == 1 &&
                user.username == "testuser" &&
                user.email == "test@example.com"
            }
            .verifyComplete()
            
        verify(userRepository).findById(1)
    }
    
    @Test
    fun `존재하지_않는_사용자_ID로_조회시_에러가_발생한다`() {
        // Given
        whenever(userRepository.findById(999)).thenReturn(Mono.empty())
        
        // When & Then
        StepVerifier.create(authService.getUserById(999))
            .expectError()
            .verify()
            
        verify(userRepository).findById(999)
    }
    
    @Test
    fun `사용자명으로_조회가_성공적으로_처리된다`() {
        // Given
        whenever(userRepository.findByUsername("testuser")).thenReturn(Mono.just(testUser))
        
        // When & Then
        StepVerifier.create(authService.getUserByUsername("testuser"))
            .expectNextMatches { user ->
                user.username == "testuser" &&
                user.email == "test@example.com"
            }
            .verifyComplete()
            
        verify(userRepository).findByUsername("testuser")
    }
    
    @Test
    fun `존재하지_않는_사용자명으로_조회시_빈_결과를_반환한다`() {
        // Given
        whenever(userRepository.findByUsername("nonexistent")).thenReturn(Mono.empty())
        
        // When & Then
        StepVerifier.create(authService.getUserByUsername("nonexistent"))
            .verifyComplete()
            
        verify(userRepository).findByUsername("nonexistent")
    }
    
    @Test
    fun `사용자_객체로_조회가_성공적으로_처리된다`() {
        // Given
        whenever(userRepository.findById(testUser.id)).thenReturn(Mono.just(testUser))
        
        // When & Then
        StepVerifier.create(authService.getUser(testUser))
            .expectNextMatches { user ->
                user.id == testUser.id &&
                user.username == testUser.username
            }
            .verifyComplete()
            
        verify(userRepository).findById(testUser.id)
    }
    
    @Test
    fun `존재하지_않는_사용자_객체로_조회시_에러가_발생한다`() {
        // Given
        val nonExistentUser = testUser.copy(id = 999)
        whenever(userRepository.findById(999)).thenReturn(Mono.empty())
        
        // When & Then
        StepVerifier.create(authService.getUser(nonExistentUser))
            .expectError()
            .verify()
            
        verify(userRepository).findById(999)
    }
    
    @Test
    fun `사용자_생성시_필수_필드가_올바르게_설정된다`() {
        // Given
        val userForm = UserFormDTO().apply {
            username = "newuser"
            password = "newpassword"
        }
        
        whenever(userRepository.save(any<User>())).thenAnswer { invocation ->
            val user = invocation.getArgument<User>(0)
            Mono.just(user.copy(id = 2))
        }
        
        // When & Then
        StepVerifier.create(authService.createUser(userForm))
            .expectNextMatches { user ->
                user.username == "newuser" &&
                user.hashedPassword == "newpassword" &&
                user.id == 2
            }
            .verifyComplete()
    }
    
    @Test
    fun `동시에_여러_사용자_조회가_정상적으로_처리된다`() {
        // Given
        val user1 = testUser.copy(id = 1, username = "user1")
        val user2 = testUser.copy(id = 2, username = "user2")
        
        whenever(userRepository.findById(1)).thenReturn(Mono.just(user1))
        whenever(userRepository.findById(2)).thenReturn(Mono.just(user2))
        
        // When & Then
        val combinedResult = Mono.zip(
            authService.getUserById(1),
            authService.getUserById(2)
        )
        
        StepVerifier.create(combinedResult)
            .expectNextMatches { (u1, u2) ->
                u1.username == "user1" &&
                u2.username == "user2"
            }
            .verifyComplete()
    }
} 